#include <fstream>
#include <iostream>
#include "setup.h"
#include "misc.h"

SetupData::SetupData()
{
	// Define variables:
	m_premium = 
	m_hasUser = 
	m_hasPass = false;

	m_sql = NULL;

	// load the contents of the data file into memory:
	printf("Loading settings...\n");

	std::ifstream inStream("settings.dat", std::ifstream::in);

	if (!inStream.good())
	{
		KGprintError("if (!inStream.good())", "Failed to open file", "You may not have write priveleges or the file settings.dat may not exist!",
			"Try running this program with elevated priveliges", &inStream, this, NULL, "mild");
		return;
	}

	std::string temp = "";

	while (!inStream.eof())
	{
		// input each line as a string:
		inStream >> temp;//todo get as whole line

		// Skip an empty line:
		if (temp == "")
			continue;

		// check if comment:
		if (temp.c_str()[0] == '/' && temp.c_str()[1] == '/')
			continue;

		// Tokenise input:
		char *str = _strdup(temp.c_str());
		str = strtok_s(str, " ", NULL);
		
		if (!str)
			continue;

		temp = str;
		str = strtok_s(NULL, "\0", NULL);

		if (!str)
		{
			KGprintError("while (!inStream.eof())::if (!str)", "Failed to load data", "bad entry",
				"entry in settings.dat may not have data", str, this, (void*)temp.c_str(), "medium");
			continue;
		}

		// Add data to memory:
		m_data[temp] = new std::string(str);

		// Clear temp memory:
		free(str);
		str = NULL;
	}

	// Close file:
	inStream.close();

	// Validate inputs from file:
	m_hasUser = verifyData("username");
	m_hasPass = verifyData("password");
}

SetupData::~SetupData()
{
	// Save settings:
	save();

	// Cleanup memory:
	for (std::map<std::string, std::string*>::iterator it = m_data.begin(); it != m_data.end(); ++it)
	{
		if (it->second != NULL)
		{
			delete it->second;
			it->second = NULL;
		}
	}

	if (m_sql != NULL)
	{
		delete m_sql;
		m_sql = NULL;
	}
}

void SetupData::save()
{
	std::fstream outStream;
	outStream.open("settings.dat", std::ofstream::out);

	if (!outStream.good())
	{
		KGprintError("if (!outStream.good())", "Failed to open file", "You may not have write priveleges or the file settings.dat may not exist!",
			"Try running this program with elevated priveliges", &outStream, this, NULL, "mild");

		return;
	}

	outStream << "// todo: file obfuscation.\n";

	for (std::map<std::string, std::string*>::iterator it = m_data.begin(); it != m_data.end(); ++it)
		if (it->second != NULL)
			outStream << it->first << " " << *it->second << "\n";

	outStream << "// This file was auto generated by Knoob Server Manager.";

	outStream.close();
}

bool SetupData::verifyData(const std::string &key)
{
	// True for key found, false for key not found:
	return (m_data.find(key) != m_data.end());
}

std::string SetupData::collectData(const char *type)
{
	return collectData("Please enter your %s: ", type);
}

std::string SetupData::collectData(const char *format, const char *type)
{
	printf(format, type);
	std::string temp = "";
	std::getline(std::cin, temp);
	return temp;
}

std::string SetupData::collectData(const char *type, const unsigned int &minLength, const unsigned int &maxLength)
{
	return collectData("Please enter your %s: ", type, minLength, maxLength);
}

std::string SetupData::collectData(const char *format, const char *type, const unsigned int &minLength, const unsigned int &maxLength)
{
	// Use 0 for unlimited maximum as maxLength!
	bool ver = false;
	std::string in = "";
	char *temp = _strdup(format);

	do
	{
		in = collectData(temp, type);
		ver = (in.length() >= minLength && (in.length() <= maxLength || !maxLength));
		char *d;

		if (!maxLength)
		{
			const char *e = "[ERROR] Your last input failed!\nPlease enter a valid input above %d characters: ";
			size_t f = strlen(e) + sizeof(char) * 4;
			d = (char*) malloc(f);
			sprintf_s(d, f, e, minLength);
		}
		else
		{
			const char *e = "[ERROR] Your last input failed!\nPlease enter a valid input between %d and %d characters: ";
			size_t f = strlen(e) + sizeof(char) * 8;
			d = (char*)malloc(f);
			sprintf_s(d, f, e, minLength);
		}

		temp = _strdup(d);
		free(d);
	} while (!ver);

	free(temp);

	return in;
}

std::string SetupData::collectPassword()
{
	std::string t, f;

	const char * ss = "Please enter your %s: ";
	const char * sr = "Please re-enter your %s: ";
	const char * sc = "Passwords did not match, try again: ";
	char *s = _strdup(ss);

	do
	{
		t = collectData(s, "password", 6, 0);
		free(s);
		s = _strdup(sr);
		f = collectData(s, "password", 6, 0);
		free(s);
		s = _strdup(sc);
	} while (t != f);

	free(s);

	return "";
}

bool SetupData::takeRemainingInput()
{
	if (!m_hasUser)
		m_data["username"] = new std::string(collectData("username"));

	if (!m_hasPass)
		m_data["password"] = new std::string(collectPassword());

	return false;
}

bool SetupData::testUser()
{
	m_sql = new MYSQL;

	mysql_init(m_sql);
	mysql_options(m_sql, MYSQL_OPT_COMPRESS, 0);
	mysql_options(m_sql, MYSQL_INIT_COMMAND, "SET autocommit=0");

	if (!mysql_real_connect(m_sql, "knoobgroup.com", "root", "*********", "server_manager", 3306, NULL, 0))
		fprintf(stderr, "Failed to connect to database.\nError: %s\n", mysql_error(m_sql));

	const char *d = "SELECT * FROM users WHERE NAME = 'kekek' AND PASSWORD = '73847yhfuihf4783fhaoi487fa83hf'";
	mysql_real_query(m_sql, d, strlen(d));

	return 0;
}

bool SetupData::testUserVerified()
{
	return 0;
}